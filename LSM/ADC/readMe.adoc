= Sample "ADC" - A reusable analog input driver for MPC5643L
:Author:    Peter Vranken 
:Email:     mailto:Peter_Vranken@Yahoo.de
:toc:       left
:xrefstyle: short
:numbered:

== About this sample

This sample implements a reusable analog input driver for the NXP MPC5643L. The
sample started as a copy of sample "RTOS". 

The startup code in folder `code\startup` is the same as for the other
samples, the sample makes use of the infrastructure it offers.

To see how the sample works you need to open a terminal software on your
host machine. You can find a terminal as part of the CodeWarrior Eclipse
IDE; go to the menu, "Window/Show View/Other/Terminal/Terminal".

Open the serial port, which is offered by the TRK-USB-MPC5643L. (On
Windows, open the Computer Management and go to the Device Manager to find
out.) The Baud rate has been selected as 115200 Bd in file
`code\mai_main.c`, 8 Bit, no parity, 1 start and stop Bit. The terminal
should print the messages, which are regularly sent by the sample code
running on the evaluation board.

In the sample, the three temperature sensors on the TRK-USB-MPC5643L are
measured with the ADC. The temperatures control the two LEDs. Normally,
they are red but if the temperature suddenly drops they change temporarily
to green. The color can be changed e.g. by blowing at the chips mounted on
the PCB.

== The ADC driver

An essential requirement for an ADC driver is the hardware triggered
sampling time of the inputs. Naive, software controlled regular sampling
of an analog input can ensure the correct mean value of the timing but the
particular sampling times undergo a jitter. Such a jitter means a sampling
error, which increases in first order with the frequency of the input
information. The sampling times need to be chosen without SW interaction.

For the MPC5643L, the ADC can be triggered from different I/O devices. The
trigger clock is routed from these devices to the ADC by the CTU. This ADC
driver uses the Enhanced Motor Control Timer as trigger source. All in all
it configures four devices:

* It uses one channel of one of the two Enhanced Motor Control Timer
  modules eTimer_0 or eTimer_1 (module eTimer_2 is not connected to the
  CTU)
* The CTU is configured to command the ADCs to do the sampling. It has the
  eTimer module as input
* The two ADCs are identical configured such that they wait for the CTU
  commands and do the conversions. (Only a single ADC is configured if all
  enabled channels should belong to the same ADC)

The ADC conversion results are written into a global array of values,
which serves as API of the module. The array is updated after each
conversion cycle. The application code can be notified by callback about
the availability of a new result. This supports synchronous processing of
the sampled analog input signal.

Fetching the channel conversion results after completion of a conversion
cycle is done by interrupt and CPU interaction. No support of the DMA mode
is implemented. This design fits well to the aimed sampling rates in the
magnitude of a Kilohertz.

=== Pin routing using SIUL

The external inputs to the ADCs are not configured by this driver. The
programming of the SIUL to route the MCU pins to the ADC inputs needs to
be done by the client code prior to starting the conversions.

=== Selection of channels

The set of channels, which is converted in every cycle is statically
configured at compile time. (The header file `adc_eTimerClockedAdc.h`
contains a #define for each physically available channel, which has to be
set to either one or zero.) It is not possible to define or change the set
of enabled channels at run-time. Moreover, it is not possible to sample
different channels at different rates. The conversion cycle is defined
(set of channels, cycle time and settings for a single conversion) and
this cycle is repeated all time long. The configuration is done with
preprocessor macros, mainly found in the header file
`adc_eTimerClockedAdc.h`.

The internal signals (TSENS_0 and TSENS_1) and VREG_1.2V can be configured
for conversion as any other channel, however this has specific side
effects:

* If and only if the temperature signals TSENS_0 and TSENS_1, channels 15,
  ADC_0 and ADC_1, respectively, are element of the set of converted
  channels then there are APIs to read the temperature signals in degree
  Celsius
* If the reference voltage VREG_1.2V, channels 10, ADC_0 and ADC_1,
  respectively, are element of the set of converted channels then the
  averaged measured reference voltage is used to calibrate all the other
  channels in Volt

=== Limitations

Some configuration items of the driver are hard-coded and not modelled as
compile-time #define's. Depending on the application, these settings and
thus the implementation of the driver can become subject to modifications.
A prominent example is the conversion timing. The related settings are
chosen for a rather slow sampling rate but better accuracy; a rate of a
few Kilohertz is targeted. Higher rates may require another timing
configuration and much higher rates could even require structural code
changes, like DMA support.

=== Static check of configuration

The configuration settings depend on one another. There are several
constraints like: A very short cycle time is impossible if the number of
active channels is large. Because we use preprocessor macros for
configuration, most of the constraints can be checked at compile time
using preprocessor conditions and the _Static_assert keyword. Therefore,
there are barely run-time errors recognized and reported by the code. A
bad configuration will simply not compile.

==== ADC as operating system clock

To avoid sampling errors at higher signal frequencies it is generally a
must to have a hardware timer to regularly trigger all conversions. If the
same clock can be used for the scheduler of the application tasks then a
software design becomes possible, where the ADC results are synchronously
acquired by hardware and processed by software and this without fearing
any race conditions. This is, what the sample demonstrates by connecting
the ADC conversions with the RTOS scheduler.

The ADC driver offers a notification callback on conversion cycle
complete. The sample installs the RTOS' system timer interrupt as this
callback and the ADC trigger source becomes the RTOS system clock at the
same time. The frequency is identical and the phase shift well-defined and
optimal; the first thing an RTOS controlled task can do is fetching and
evaluating the ADC results without fearing any race conditions.

Note, the sample uses an ADC cycle of 1 ms, yielding the standard system
clock of 1 kHz for the RTOS. The change of the cycle time is as easy as
changing a configuration macro in the ADC driver. There's no technical
issue in doing so, but the RTOS documentation will become wrong wherever
it mentions the unit of time designations.

== The test and calibration data of the MCU

TODOC Reusable module to read the test and calibration data page of the
MCU

== Book E versus VLE

The implementation of the function to read the MCU's test and calibration
data is done in assembler and depends on the instruction set. It has been
made for Book E, but VLE will follow soon.

The rest of the sample does not depend on the chosen instruction set.

== Tools

=== Environment

==== Command line based build

The makefiles and related scripts require a few settings of the
environment in the host machine. In particular, the location of the GNU
compiler installation needs to be known and the PATH variable needs to
contain the paths to the required tools. 

For Windows users there is a shortcut to PowerShell in the root of this
project (not sample), which opens the shell with the prepared environment.
Furthermore, it creates an alias to the appropriate GNU make executable.
You can simply type `make` from any location to run MinGW32 GNU make.

The PowerShell process reads the script `setEnv.ps1`, located in the
project root, too, to configure the environment. This script requires
configuration prior to its first use. Windows users open it in a text
editor and follow the given instructions that are marked by TODO tags.
Mainly, it's about specifying the installation directory of GCC.

Non-Windows users will read this script to see, which (few) environmental
settings are needed to successfully run the build and prepare an according
script for their native shell.

==== Eclipse for building, flashing and debugging

Flashing and debugging is always done using the NXP CodeWarrior Eclipse
IDE, which is available for free download. If you are going to run the
application build from Eclipse, too, then the same environmental settings
as decribed above for a shell based build need to be done for Eclipse. The
easiest way to do so is starting Eclipse from a shell, that has executed
the script `setEnv.ps1` prior to opening Eclipse.

For Windows users the script `CW-IDE.ps1` has been prepared. This script
requires configuration prior to its first use. Windows users open it in a
text editor and follow the given instructions that are marked by TODO
tags. Mainly, it's about specifying the installation directory of
CodeWarrior.

Non-Windows users will read this script to see, which (few) environmental
and path settings are needed to successfully run the build under control
of Eclipse and prepare an according script for their native shell.

Once everything is prepared, the CodeWarrior Eclipse IDE will never be
started other than by clicking the script `CW-IDE.ps1` or its equivalent
on non-Windows hosts.

See https://github.com/PeterVranken/TRK-USB-MPC5643L[project overview] and
https://github.com/PeterVranken/TRK-USB-MPC5643L/wiki/Tools-and-Installation[GitHub
Wiki] for more details about downloading and installing the required
tools.

=== Compiler and makefile

Compilation and linkage are makefile controlled. The compiler is GCC
(MinGW-powerpc-eabivle-4.9.4). The makefile is made generic and can be
reused for other projects, not only for a tiny "Hello World" with a few
source files. It supports a number of options (targets); get an overview
by typing:
 
    cd <projectRoot>/LSM/ADC
    mingw32-make help

The main makefile `GNUmakefile` has been configured for the build of
sample "ADC". Type:

    mingw32-make -s build 
    mingw32-make -s build CONFIG=PRODUCTION

to produce the flashable files `bin\ppc\DEBUG\TRK-USB-MPC5643L-ADC.elf`
and `bin\ppc\PRODUCTION\TRK-USB-MPC5643L-ADC.elf`.

NOTE: The makefile requires the MinGW port of the make processor. The Cygwin
port will fail with obscure, misleading error messages. It's safe to use
the `make.exe` from the compiler installation archive. The makefile is
designed to run on different host systems but has been tested with Windows
7 only.

=== Flashing and debugging

The sample code can be flashed and debugged with the CodeWarrior IDE.

To flash the `*.elf` file, open the CodeWarrior IDE, go to the menu, click
"Window/Show View/Other/Debug/Debugger Shell". In the debugger shell
window, type:

    cd <rootFolderOfSample>/makefile/debugger
    source flashDEBUG.tcl
    
or

    source flashPRODUCTION.tcl

The debugger is started by a click on the black triangle next to the blue
icon "bug", then click "Debug Configurations.../CodeWarrior/Debug ADC
(DEBUG)". Confirm and start the debugger with a last click on button
"Debug".

You can find more details on using the CodeWarrior IDE at
https://github.com/PeterVranken/TRK-USB-MPC5643L/wiki/Tools-and-Installation.

== Code architecture

This sample builds on the basic sample "startup" located in a sibling
folder and it integrates the other packages "printf" and "RTOS". "ADC" is
compiled for the Book E instruction set. All build settings and the
software architecture are identical to "startup". Please refer to
https://github.com/PeterVranken/TRK-USB-MPC5643L/blob/master/LSM/startup/readMe.adoc[LSM/startup/readMe.adoc]
for details.

=== API

The ADC driver offers an API for using it. 
  footnote:[This API is an extension to the
https://github.com/PeterVranken/TRK-USB-MPC5643L/blob/master/LSM/startup/readMe.adoc[API
offered by the startup code], which is required, too, for implementing critical sections if coherent reading of more than one channel result is a requirement.]
  This section outlines, which functions are available and how to use them.
Detailed information is found as
https://github.com/PeterVranken/TRK-USB-MPC5643L/blob/master/LSM/ADC/code/ADC/adc_eTimerClockedAdc.c[source code] comments.

==== Driver initialization

TODOC Coherent reading of single results, several results with respect to
conversion cycle, configuration at compile-time

==== Retrieving conversion results

TODOC Calibration with bandgap reference source, coherency of readings
with respect to conversion cycles

==== Mutual exclusion of tasks by priority ceiling protocol
TODOC ihw_, PCP not if RTOS connected (highest prio)

==== Diagnosis: Age

