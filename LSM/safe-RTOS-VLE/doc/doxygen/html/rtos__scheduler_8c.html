<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>safe-RTOS(VLE): rtos_scheduler.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">safe-RTOS(VLE)
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">safe-RTOS (VLE) - A simple RTOS with safety support for MPC5643L</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('rtos__scheduler_8c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rtos_scheduler.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;limits.h&gt;</code><br />
<code>#include &lt;assert.h&gt;</code><br />
<code>#include &quot;MPC5643L.h&quot;</code><br />
<code>#include &quot;<a class="el" href="typ__types_8h_source.html">typ_types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rtos__process_8h_source.html">rtos_process.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rtos__external_interrupt_8h_source.html">rtos_externalInterrupt.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rtos__priority_ceiling_protocol_8h_source.html">rtos_priorityCeilingProtocol.h</a>&quot;</code><br />
<code>#include &quot;rtos_ivorHandler.h&quot;</code><br />
<code>#include &quot;<a class="el" href="rtos__system_memory_protection_unit_8h_source.html">rtos_systemMemoryProtectionUnit.h</a>&quot;</code><br />
<code>#include &quot;rtos_scheduler_defSysCalls.h&quot;</code><br />
<code>#include &quot;<a class="el" href="rtos_8h_source.html">rtos.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9e214eed5eb27fd51e72227fb62f9b8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8c.html#a9e214eed5eb27fd51e72227fb62f9b8a">rtos_osCreateEvent</a> (unsigned int *pEventId, unsigned int tiCycleInMs, unsigned int tiFirstActivationInMs, unsigned int priority, unsigned int minPIDToTriggerThisEvent)</td></tr>
<tr class="separator:a9e214eed5eb27fd51e72227fb62f9b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad638a1d6495b0948343a90257e6410d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8c.html#ad638a1d6495b0948343a90257e6410d4">rtos_osRegisterInitTask</a> (int32_t(*initTaskFct)(uint32_t PID), unsigned int PID, unsigned int tiTaskMaxInUs)</td></tr>
<tr class="separator:ad638a1d6495b0948343a90257e6410d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f82142ad49b24808f65723a0842be8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8c.html#ad2f82142ad49b24808f65723a0842be8">rtos_osRegisterUserTask</a> (unsigned int idEvent, int32_t(*userModeTaskFct)(uint32_t PID), unsigned int PID, unsigned int tiTaskMaxInUs)</td></tr>
<tr class="separator:ad2f82142ad49b24808f65723a0842be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68096423d941e1dc670a6ec2e37d5275"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8c.html#a68096423d941e1dc670a6ec2e37d5275">rtos_osRegisterOSTask</a> (unsigned int idEvent, void(*osTaskFct)(void))</td></tr>
<tr class="separator:a68096423d941e1dc670a6ec2e37d5275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaae84408e099b28495d703994100c16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8c.html#aeaae84408e099b28495d703994100c16">rtos_osGrantPermissionRunTask</a> (unsigned int pidOfCallingTask, unsigned int targetPID)</td></tr>
<tr class="separator:aeaae84408e099b28495d703994100c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24d0fa9208d5675e03cc931a08e52fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8c.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel</a> (void)</td></tr>
<tr class="separator:ab24d0fa9208d5675e03cc931a08e52fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2436c0e309c481d81292b149f22520aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8c.html#a2436c0e309c481d81292b149f22520aa">rtos_osTriggerEvent</a> (unsigned int idEvent)</td></tr>
<tr class="separator:a2436c0e309c481d81292b149f22520aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f63a85fcf6b79022d8039ae974aba96"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8c.html#a5f63a85fcf6b79022d8039ae974aba96">rtos_getNoActivationLoss</a> (unsigned int idEvent)</td></tr>
<tr class="separator:a5f63a85fcf6b79022d8039ae974aba96"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file implements a simple yet "safe" Real Time Operating System (RTOS) for the MPC5643L.<br />
 The RTOS offers a strictly priority controlled scheduler. The user code is organized in processes and tasks. Any task belongs to one of the processes. Different processes have different privileges. The concept is to use the process with highest privileges for the safety tasks.<br />
 A task is activated by an event; an application will repeatedly use the API <a class="el" href="rtos__scheduler_8c.html#a9e214eed5eb27fd51e72227fb62f9b8a">rtos_osCreateEvent()</a> to define the conditions or points in time, when the tasks have to become due.<br />
 Prior to the start of the scheduler (and thus prior to the beginning of the pseudo-parallel, concurrent execution of the tasks) all later used task are registered at the scheduler; an application will repeatedly use the APIs <a class="el" href="rtos__scheduler_8c.html#ad2f82142ad49b24808f65723a0842be8">rtos_osRegisterUserTask()</a> and <a class="el" href="rtos__scheduler_8c.html#a68096423d941e1dc670a6ec2e37d5275">rtos_osRegisterOSTask()</a>.<br />
 After all needed tasks are registered the application will start the RTOS' kernel by calling the API <a class="el" href="rtos__scheduler_8c.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel()</a> and task scheduling begins.<br />
 A task is mainly characterized by the owning process, the task function and a priority; the C code function is invoked in the context of the process and at given priority level when the task is activated. The function is executed either until the task function is left or the task function or one of its sub-routines requests task termination by means of a system call or the task function is aborted by an exception.<br />
 "Context of a process" mainly relates to the memory management concept. Any process has its private memory. This memory is either write-accessible only for the owning process or for the owning process and all other processes with higher privileges. The "or" in this statement is a matter of project configuration. A few more elements are process dependent; many system calls are restricted to processes of sufficient privileges.<br />
 "Activated" does still not necessarily mean executing for a task; the more precise wording is that the activation makes a task immediately and unconditionally "ready" (i.e. ready for execution). If more than a single task are ready at a time then the function of the task with higher priority is executed first and the function of the other task will be served only after completion of the first. Several tasks can be simultaneously ready and one of them will be executed, this is the one and only "running" task.<br />
 "Are ready at a time" does not necessarily mean that both tasks have been activated at the same point in time. If task A of priority Pa is activated first and as only task then it'll be executed regardless of its priority. If task B of priority Pb is activated later, but still before A has completed then we have two tasks which have been activated "at a time". The priority relation decides what happens:<br />
 If Pa &gt;= Pb then A is completed and B will be started and executed only after A has completed.<br />
 If Pb &gt; Pa then task A turns from state running back to state ready and B becomes the running task until it completes. Now A as remaining ready, yet uncompleted task becomes the running task again and it can complete.<br />
 With other words, if a task is activated and it has a higher priority than the running task then it'll preempt the running task and it'll become the running task itself.<br />
 If no task is ready at all then the scheduler continues the original code thread, which is the code thread starting in function main() and which first registers the tasks and then starts the kernel. (Everything in this code thread, which is placed behind the call of API <a class="el" href="rtos__scheduler_8c.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel()</a> is called the "idle task".)<br />
 The implemented scheduling scheme leads to a strictly hierarchical execution order of tasks. This scheme is sometimes referred to as scheduling of tasks of Basic Conformance Class (BCC). It's simple, less than what most RTOSs offer, but still powerful enough for the majority of industrial use cases.<br />
 The activation of a task can be done by software, using API function rtos_triggerEvent() or it can be done by the scheduler on a regular time base. In the former case the task is called an event task, the latter is a cyclic task with fixed period time.<br />
 The RTOS implementation is tightly connected to the implementation of interrupt services. Interrupt services, e.g. to implement I/O operations for the tasks, are registered with <a class="el" href="rtos_8h.html#a72c496a57feceb72a84ce41895e179c9">rtos_osInstallInterruptHandler()</a>.<br />
 Any I/O interrupts can be combined with the tasks. Different to most RTOS we don't impose a priority ordering between tasks and interrupts. A conventional design would put interrupt service routines (ISR) at higher priorities than the highest task priority but this is not a must. Certain constraints result from safety considerations not from technical aspects.<br />
 Effectively, there's no difference between tasks and ISRs. All what has been said for tasks with respect to priority, states and preemption holds for ISRs and the combination of tasks and ISRs, too.<br />
 Compared to other "safe" RTOSs a quite little number of lines of code is required to implement the RTOS - this is because of the hardware capabilities of the interrupt controller INTC, which has much of an RTOS kernel in hardware. The RTOS is just a wrapper around these hardware capabilities. The reference manual of the INTC partly reads like an excerpt from the OSEK/VDX specification; it effectively implements the basic task conformance classes BCC1 and mostly BCC2 from the standard. Since we barely add software support, our operating system is by principle restricted to these conformance classes.<br />
 Basic conformance class means that a task cannot suspend intentionally and ahead of its normal termination. Once started, it needs to be entirely executed. Due to the strict priority scheme it'll temporarily suspend only for the sake of tasks of higher priority (but not voluntarily or on own desire). Another aspect of the same is that the RTOS doesn't know task to task events &ndash; such events are usually the way intentional suspension and later resume of tasks is implemented.</p>
<p>Safety:<br />
 The RTOS is based on the "unsafe" counterpart published at <a href="https://github.com/PeterVranken/TRK-USB-MPC5643L/tree/master/LSM/RTOS-VLE">https://github.com/PeterVranken/TRK-USB-MPC5643L/tree/master/LSM/RTOS-VLE</a>. All explanations given there still hold. In this project, we add a safety concept. This needs to start with a specification of what we expect from a "safe" RTOS:<br />
 "If the implementation of a task, which is meant the supervisory or safety task, is itself free of faults then the RTOS shall guarantee that this task is correctly and timely executed regardless of whatever imaginable failures are made by any other process."\n
  This requirement serves at the same time as the definition of the term "safe", when used in the context of this RTOS. safe-RTOS promises no more than this requirement says. As a consequence, a software made with this RTOS is not necessarily safe and even if it is then the system using that software is still not necessarily safe.<br />
 The implementation uses the CPU's "problem state" in conjunction with exception handlers and memory protection to meet the requirement. More details can be found at <a href="https://github.com/PeterVranken/TRK-USB-MPC5643L/tree/master/LSM/safe-RTOS-VLE#3-the-safety-concept">https://github.com/PeterVranken/TRK-USB-MPC5643L/tree/master/LSM/safe-RTOS-VLE#3-the-safety-concept</a>.</p>
<p>Copyright (C) 2017-2019 Peter Vranken (<a href="#" onclick="location.href='mai'+'lto:'+'Pet'+'er'+'_Vr'+'an'+'ken'+'@Y'+'aho'+'o.'+'de'; return false;">Peter<span style="display: none;">.nosp@m.</span>_Vra<span style="display: none;">.nosp@m.</span>nken@<span style="display: none;">.nosp@m.</span>Yaho<span style="display: none;">.nosp@m.</span>o.de</a>)</p>
<p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or any later version.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p>
<p>You should have received a copy of the GNU Lesser General Public License along with this program. If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a9e214eed5eb27fd51e72227fb62f9b8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a> rtos_osCreateEvent </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>pEventId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tiCycleInMs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tiFirstActivationInMs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>minPIDToTriggerThisEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creation of an event. The event can be cyclically triggering or software triggerd. An event is needed to activate a user task. Therefore, any reasonable application will ceate at least one event.<br />
 This function is repeatedly called by the application code for each required event. All calls of this function need to be done prior to the start of the kernel using <a class="el" href="rtos__scheduler_8c.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel()</a>.<br />
 </p><dl class="section return"><dt>Returns</dt><dd><em>rtos_err_noError</em> (zero) if the event could be created. The maximum number of events is limited to <a class="el" href="rtos_8h.html#a6f73e4184494130fdd081ee3b603a732">RTOS_MAX_NO_EVENTS</a> by hardware constraints. If the event cannot be created due to this constraint or if the event descriptor contains invalid data then then the function returns a non zero value from enumeration <em>rtos_errorCode_t</em>.<br />
 An assertion in the calling code is considered appropriate to handle the error because it'll always be a static configuration error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEventId</td><td>All events are identified by a positive integer. Normally this ID is returned by reference in * <em>pEventId</em>. If the event cannot be created then <a class="el" href="rtos_8h.html#ac4ea516ad4edd46b1088804cf463bc84">RTOS_INVALID_EVENT_ID</a> is returned in * <em>pEventId</em>.<br />
 Note, it is guaranteed to the caller that the returned ID is not an arbitrary, meaningless number. Instead, the ID is counted from zero in order of creating events. The first call of this function will return 0, the second 1, and so on. This simplifies ID handling in the application code, constants can mostly be applied as the IDs are effectively known at compile time. </td></tr>
    <tr><td class="paramname">tiCycleInMs</td><td>The period time for regularly triggering events in ms.<br />
 The permitted range is 0..2^30-1. 0 means no regular, timer controlled trigger and the event is only enabled for software trigger using rtos_triggerEvent() (permitted for interrupts or other tasks). </td></tr>
    <tr><td class="paramname">tiFirstActivationInMs</td><td>The first trigger of the event in ms after start of kernel. The permitted range is 0..2^30-1.<br />
 Note, this setting is useless if a cycle time zero in <em>tiCycleInMs</em> specifies a non regular event. <em>tiFirstActivationInMs</em> needs to be zero in this case, too. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the event in the range 1..(<a class="el" href="rtos_8h.html#aaa872380c24395eaa01addbd96f49edf">RTOS_KERNEL_PRIORITY</a>-1). Different events can share the same priority or have different priorities. The priotrity of an event is the priority of all associated tasks at the same time. The execution of tasks, which share the priority will be serialized when they are activated at same time or with overlap.<br />
 Note the safety constraint that the highest permitted priorities, <a class="el" href="rtos_8h.html#a9520f3e002688cbf786b1d0134350dbe">RTOS_MAX_LOCKABLE_PRIORITY</a>+1 till <a class="el" href="rtos_8h.html#aaa872380c24395eaa01addbd96f49edf">RTOS_KERNEL_PRIORITY</a>-1, are available only to events, which solely have tasks associated that belong to the process with highest process ID in use.<br />
 Note, the order in which events are created can affect the priority in a certain sense. If two events are created with same priority and when they at runtime become due at the same OS time tick then the earlier created event will trigger its associated user tasks before the later ceated event. </td></tr>
    <tr><td class="paramname">minPIDToTriggerThisEvent</td><td>An event can be triggered by user code, using rtos_triggerEvent(). However, tasks belonging to less privileged processes must not generally have permission to trigger events that may activate tasks of higher privileged processes. Since an event is not process related, we make the minimum process ID, which is required to trigger this event, an explicitly configured property of the event.<br />
 Only tasks belonging to a process with PID &gt;= <em>minPIDToTriggerThisEvent</em> are permitted to trigger this event.<br />
 The range of <em>minPIDToTriggerThisEvent</em> is 0 ... (<a class="el" href="rtos_8h.html#a18500a557ecd5ebbcefbacba22b58d7e">RTOS_NO_PROCESSES</a>+1). 0 and 1 both mean, all processes may trigger the event, (<a class="el" href="rtos_8h.html#a18500a557ecd5ebbcefbacba22b58d7e">RTOS_NO_PROCESSES</a>+1) means only OS code can trigger the event. (<a class="el" href="rtos_8h.html#a18500a557ecd5ebbcefbacba22b58d7e">RTOS_NO_PROCESSES</a>+1) is available as <a class="el" href="rtos_8h.html#a7c87eedf96c681bbc685574bfd5a6bc3">RTOS_EVENT_NOT_USER_TRIGGERABLE</a>, too. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Never call this function after the call of <a class="el" href="rtos__scheduler_8c.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel()</a>! </dd>
<dd>
This function must be called by trusted code in supervisor mode only. </dd></dl>

</div>
</div>
<a class="anchor" id="ad638a1d6495b0948343a90257e6410d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a> rtos_osRegisterInitTask </td>
          <td>(</td>
          <td class="paramtype">int32_t(*)(uint32_t PID)&#160;</td>
          <td class="paramname"><em>initTaskFct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>PID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tiTaskMaxInUs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registration of a process initialization task. This function is typically repeatedly called by the operating system initialization code as often as there are processes, which need initialization.<br />
 Initialization functions are particularly useful for the user processes. They allow having user provided code, that is run prior to the start of the scheduler, in a still race condition free environment but already with full protection against runtime failures.<br />
 All calls of this function need to be done prior to the start of the kernel using <a class="el" href="rtos__scheduler_8c.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel()</a>. </p><dl class="section return"><dt>Returns</dt><dd><em>rtos_err_noError</em> (zero) if the task could be registered. The maximum number of initialization tasks is one per process and one for the OS. If the limit is exceeded or if the task specification is invalid then the function returns a non zero value from enumeration <em>rtos_errorCode_t</em>.<br />
 An assertion in the calling code is considered appropriate to handle the error because it'll always be a static configuration error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initTaskFct</td><td>The initialization function, which is run once in process <em>PID</em>.<br />
 The function gets the ID of the process it belongs to as argument.<br />
 The function returns a signed value. If the value is negative then it is considered an error, which is counted as error <a class="el" href="rtos_8h.html#a32453f0c8f6c8845c879a54e4288c2b4">RTOS_ERR_PRC_USER_ABORT</a> in the owning process and the scheduler will not start up. </td></tr>
    <tr><td class="paramname">PID</td><td>The process the task belongs to by identifier. We have a fixed, limited number of four processes (<a class="el" href="rtos_8h.html#a18500a557ecd5ebbcefbacba22b58d7e">RTOS_NO_PROCESSES</a>) plus the kernel process, which has ID 0. The range of process IDs to be used here is 0 .. <a class="el" href="rtos_8h.html#a18500a557ecd5ebbcefbacba22b58d7e">RTOS_NO_PROCESSES</a>.<br />
 At kernel initialization time, the registered user process initialization functions will be called in the order of rising PID, followed by the registered kernel process initialization function. </td></tr>
    <tr><td class="paramname">tiTaskMaxInUs</td><td>Time budget for the function execution in Microseconds. The budget relates to deadline monitoring, i.e. it is a world time budget, not an execution time budget.<br />
 Deadline monitoring is supported up to a maximum execution time of <a class="el" href="rtos_8h.html#a1f387767ac5768e23a4a7aa1ef5084f7">RTOS_TI_DEADLINE_MAX_IN_US</a> Microseconds.<br />
 A value of zero means that deadline monitoring is disabled for the run of the initialization function.<br />
 There's no deadline monitoring for OS tasks. If <em>PID</em> is zero then <em>tiTaskMaxInUS</em> meeds to be zero, too. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Never call this function after the call of <a class="el" href="rtos__scheduler_8c.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel()</a>! </dd>
<dd>
This function must be called by trusted code in supervisor mode only. </dd></dl>

</div>
</div>
<a class="anchor" id="ad2f82142ad49b24808f65723a0842be8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a> rtos_osRegisterUserTask </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t(*)(uint32_t PID)&#160;</td>
          <td class="paramname"><em>userModeTaskFct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>PID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tiTaskMaxInUs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registration of an event triggered user mode task. Normal, event activated tasks can be registered for later execution. This function is repeatedly called by the application code as often as user mode tasks are required.<br />
 All calls of this function need to be done prior to the start of the kernel using <a class="el" href="rtos__scheduler_8c.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel()</a>. </p><dl class="section return"><dt>Returns</dt><dd><em>rtos_err_noError</em> (zero) if the task could be registered. The maximum number of tasks is limited to <a class="el" href="rtos_8h.html#a70565e1202ec02ce7048d39775cccb2d">RTOS_MAX_NO_USER_TASKS</a> (regardless, how they are distributed among processes). If the limit is exceeded or if the task specification is invalid then the function returns a non zero value from enumeration <em>rtos_errorCode_t</em>.<br />
 An assertion in the calling code is considered appropriate to handle the error because it'll always be a static configuration error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idEvent</td><td>The task is activated by an event. This call associates the registered task with an already created event. See <a class="el" href="rtos__scheduler_8c.html#a9e214eed5eb27fd51e72227fb62f9b8a">rtos_osCreateEvent()</a>.<br />
 The order of registration of several tasks (both, OS and user mode) with one and the same event matters. The tasks will be acivated in order of registration whenever the event becomes due or is triggered by software. </td></tr>
    <tr><td class="paramname">userModeTaskFct</td><td>The task function, which is run in process <em>PID</em> every time, the event <em>idEvent</em> triggers.<br />
 The function gets the ID of the process it belongs to as argument.<br />
 The function returns a signed value. If the value is negative then it is considered an error, which is counted as error <a class="el" href="rtos_8h.html#a32453f0c8f6c8845c879a54e4288c2b4">RTOS_ERR_PRC_USER_ABORT</a> in the owning process. (And after a number of errors a supervisory task could force a shutdown of the process). </td></tr>
    <tr><td class="paramname">PID</td><td>The process the task belongs to by identifier. We have a fixed, limited number of four processes (<a class="el" href="rtos_8h.html#a18500a557ecd5ebbcefbacba22b58d7e">RTOS_NO_PROCESSES</a>). The range of process IDs to be used here is 1 .. <a class="el" href="rtos_8h.html#a18500a557ecd5ebbcefbacba22b58d7e">RTOS_NO_PROCESSES</a>.<br />
 </td></tr>
    <tr><td class="paramname">tiTaskMaxInUs</td><td>Time budget for the task in Microseconds. This budget is granted for each activation of the task, i.e. each run of <em>userModeTaskFct()</em>. The budget relates to deadline monitoring, i.e. it is a world time budget, not an execution time budget.<br />
 Deadline monitoring is supported up to a maximum execution time of <a class="el" href="rtos_8h.html#a1f387767ac5768e23a4a7aa1ef5084f7">RTOS_TI_DEADLINE_MAX_IN_US</a> Microseconds.<br />
 A value of zero means that deadline monitoring is disabled for the task.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Never call this function after the call of <a class="el" href="rtos__scheduler_8c.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel()</a>! </dd>
<dd>
This function must be called by trusted code in supervisor mode only. </dd></dl>

</div>
</div>
<a class="anchor" id="a68096423d941e1dc670a6ec2e37d5275"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a> rtos_osRegisterOSTask </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>osTaskFct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registration of an event triggered operating system task. Event activated tasks can be registered for later execution. This function is repeatedly called by the application code as often as operating system tasks are required.<br />
 All calls of this function need to be done prior to the start of the kernel using <a class="el" href="rtos__scheduler_8c.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel()</a>. </p><dl class="section return"><dt>Returns</dt><dd><em>rtos_err_noError</em> (zero) if the task could be registered. The maximum number of tasks is limited to <a class="el" href="rtos_8h.html#a70565e1202ec02ce7048d39775cccb2d">RTOS_MAX_NO_USER_TASKS</a> (regardless, how they are distributed among processes). If the limit is exceeded or if the task specification is invalid then the function returns a non zero value from enumeration <em>rtos_errorCode_t</em>.<br />
 An assertion in the calling code is considered appropriate to handle the error because it'll always be a static configuration error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idEvent</td><td>The task is activated by an event. This call associates the registered task with an already created event. See <a class="el" href="rtos__scheduler_8c.html#a9e214eed5eb27fd51e72227fb62f9b8a">rtos_osCreateEvent()</a>.<br />
 The order of registration of several tasks (both, OS and user mode) with one and the same event matters. The tasks will be acivated in order of registration whenever the event becomes due or is triggered by software. </td></tr>
    <tr><td class="paramname">osTaskFct</td><td>The task function, which is run in the OS context every time, the event <em>idEvent</em> triggers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Never call this function after the call of <a class="el" href="rtos__scheduler_8c.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel()</a>! </dd>
<dd>
This function must be called by trusted code in supervisor mode only. </dd></dl>

</div>
</div>
<a class="anchor" id="aeaae84408e099b28495d703994100c16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtos_osGrantPermissionRunTask </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pidOfCallingTask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>targetPID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operating system initialization function: Grant permissions for using the service rtos_runTask to particular processes. By default, the use of that service is not allowed.<br />
 By principle, offering service rtos_runTask makes all processes vulnerable, which are allowed as target for the service. A failing, straying process can always hit some ROM code executing the system call with arbitrary register contents, which can then lead to errors in an otherwise correct process.<br />
 This does not generally break the safety concept, the potentially harmed process can for example be anyway supervised by another, unaccessible supervisory process. Consequently, we can offer the service at least on demand. A call of this function enables the service for a particular pair of calling process and targeted process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pidOfCallingTask</td><td>The tasks belonging to process with PID <em>pidOfCallingTask</em> are granted permission to run a task in another process. The range is 1 .. <a class="el" href="rtos_8h.html#a18500a557ecd5ebbcefbacba22b58d7e">RTOS_NO_PROCESSES</a>, which is double-checked by assertion. </td></tr>
    <tr><td class="paramname">targetPID</td><td>The tasks started with service rtos_runTask() may be run in process with PID <em>targetPID</em>. The range is 1 .. maxPIDInUse-1, which is double-checked later.<br />
 <em>pidOfCallingTask</em> and <em>targetPID</em> must not be identical, which is double-checked by assertion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>It would break the safety concept if we permitted the process with highest privileges to become the target of the service. This is double-checked not here (when it is not yet defined, which particular process that will be) but as part of the RTOS startup procedure; a bad configuration can therefore lead to a later reported run-time error. </dd>
<dd>
This function must be called from the OS context only. It is intended for use in the operating system initialization phase. It is not reentrant. The function needs to be called prior to <a class="el" href="rtos__scheduler_8c.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ab24d0fa9208d5675e03cc931a08e52fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a> rtos_osInitKernel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialization and start of the RTOS kernel.<br />
 The function initializes a hardware device to produce a regular clock tick and connects the OS schedule function onOsTimerTick() with the interrupt raised by this timer device. After return, the RTOS is running with a regular clock tick for scheduling the tasks. Period time is <a class="el" href="rtos_8h.html#adac6ecd4fb33ad903127c325c5aff1e0">RTOS_CLOCK_TICK_IN_MS</a> Milliseconds.<br />
 The function can be called before or after the External Interrupts are enabled at the CPU (see rtos_osResumeAllInterrupts()). Normal behavior is however, no to resume the interrupt processing before and let this be done by <a class="el" href="rtos__scheduler_8c.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel()</a>. </p><dl class="section return"><dt>Returns</dt><dd><em>rtos_err_noError</em> (zero) if the scheduler could be started. The function returns a non zero value from enumeration <em>rtos_errorCode_t</em> if a configuration error is detected. The software must not start up in this case. Since it is only about static configuration, the returned error may be appropriately handled by an assertion. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The RTOS kernel applies the Periodic Interrupt Timer 0 (PIT0) as clock source. This timer is reserved to the RTOS and must not be used at all by some other code. </dd>
<dd>
All application tasks need to be registered before invoking this function, see <a class="el" href="rtos__scheduler_8c.html#ad638a1d6495b0948343a90257e6410d4">rtos_osRegisterInitTask()</a>, <a class="el" href="rtos__scheduler_8c.html#ad2f82142ad49b24808f65723a0842be8">rtos_osRegisterUserTask()</a> and <a class="el" href="rtos__scheduler_8c.html#a68096423d941e1dc670a6ec2e37d5275">rtos_osRegisterOSTask()</a>. </dd>
<dd>
This function must be called from the OS context only. The call of this function will end the operating system initialization phase. </dd></dl>

</div>
</div>
<a class="anchor" id="a2436c0e309c481d81292b149f22520aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rtos_osTriggerEvent </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idEvent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Trigger an event to activate all associated tasks. A event, which had been registered with cycle time zero is normally not executed. It needs to be triggered with this function in order to make its associated tasks run once, i.e. to make its task functions executed once as result of this call.<br />
 This function can be called from any task or ISR. However, if the calling task belongs to the set of tasks associated with <em>idEvent</em>, then it'll have no effect but an accounted activation loss; an event can be re-triggered only after all associated activations have been completed. There is no activation queueing. The function returns <em>false</em> in this case.<br />
 Note, the system respects the priorities of the activated tasks. If a task of priority higher than the activating task is activated by the triggered event then the activating task is immediately preempted to the advantage of the activated task. Otherwise the activated task is chained and executed after the activating task. </p><dl class="section return"><dt>Returns</dt><dd>There is no activation queuing. Consequently, triggering the event can fail if at least one of the associated tasks has not yet completed after the previous trigger of the event. The function returns <em>false</em> and the activation loss counter of the event is incremented. (See <a class="el" href="rtos__scheduler_8c.html#a5f63a85fcf6b79022d8039ae974aba96">rtos_getNoActivationLoss()</a>.) In this situation, the new trigger is entirely lost, i.e. none of the associated tasks will be activated by the new trigger. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idEvent</td><td>The ID of the event to activate as it had been got by the creation call for that event. (See <a class="el" href="rtos__scheduler_8c.html#a9e214eed5eb27fd51e72227fb62f9b8a">rtos_osCreateEvent()</a>.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The function is indented to start a non cyclic task by application software trigger but can be applied to cyclic tasks, too. In which case the task function of the cyclic task would be invoked once additionally. Note, that an event activation loss is not unlikely in this case; the cyclic task may currently be busy. </dd>
<dd>
It is not forbidden but useless to let a task activate itself by triggering the event it is associated with. This will have no effect besides incrementing the activation loss counter for that event. </dd>
<dd>
This function must be called from the OS context only. It may be called from an ISR to implement delegation to a user task. </dd></dl>

</div>
</div>
<a class="anchor" id="a5f63a85fcf6b79022d8039ae974aba96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int rtos_getNoActivationLoss </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idEvent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An event, which becomes due may not be able to activate all its associated tasks because they didn't terminate yet after their previous activation. It doesn't matter if this happens because a cyclic task becomes due or because an event task has been triggered by software (using rtos_triggerEvent()). The scheduler counts the failing activations on a per event base. The current value can be queried with this function. </p><dl class="section return"><dt>Returns</dt><dd>Get the current number of triggers of the given event, which have failed since start of the RTOS scheduler. The counter is saturated and will not wrap around.<br />
 The returned count can be understood as number of task overrun events for all associated tasks. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idEvent</td><td>Each event has its own counter. The value is returned for the given event. The range is 0 .. number of registered events minus one (double-checked by assertion). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function can be called from both, the OS context and a user task. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_050edd66366d13764f98250ef6db77f6.html">code</a></li><li class="navelem"><a class="el" href="dir_9cd24f4fec2e6f6bedbcc5407321d78a.html">system</a></li><li class="navelem"><a class="el" href="dir_34effe5aae1be93d744f092611be46f1.html">RTOS</a></li><li class="navelem"><a class="el" href="rtos__scheduler_8c.html">rtos_scheduler.c</a></li>
    <li class="footer">Generated on Tue Sep 17 2019 22:34:24 for safe-RTOS(VLE) by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
