= Sample "kernelBuilder" - A platform to build your RTOS for MPC5643L
:Author:    Peter Vranken 
:Email:     mailto:Peter_Vranken@Yahoo.de
:toc:       left
:xrefstyle: short
:numbered:

== About this sample

This sample offers a pair of IVOR #4 (External Interrupt) and IVOR #8
(System Call) handlers, which are designed to support the build of a
single core operating system kernel for the NXP MPC5643L. The IVOR #4
handler supports both, ordinary interrupt service routines (ISR) and
kernel relevant ISRs.

The ordinary ISRs behave as usual, they preempt an execution context at
arbitrary code location, do their job and continue the same context at the
location of preemption. This is exactly the behavior of the IVOR #4
handler in the common startup code of the other samples.

The kernel relevant ISR is new. It has a return value, which permits to
demand the switch to another execution context. Preemption happens
identical to the ordinary ISR at arbitrary code location. After servicing
the interrupt source, on return, it decides to either behave like the
ordinary ISR and to continue the preempted context or it can decide to
continue any other execution context. "Any other execution context"
normally is one of those, which had been left by a similar, earlier
decision, i.e. which had _not_ been continued at that time.

Our simplest sample code is a "scheduler", which implements a regular timer
interrupt as kernel relevant ISR. Unconditionally in each tick, it demands
a context switch between two existing execution contexts. The CPU executes
both program paths alternatingly and pseudo-parallel.

The second IVOR handler implements the concept of system calls. These are
software interrupt, which preempt a context at the particular location, at
which the code contains the system call instruction. The difference to an
ordinary branch is that the same CPU mechanisms are used as for
asynchronous interrupts; in particular the CPU returns from user mode back
to supervisor mode and it disables the servicing of External Interrupts.
The latter ensures that system calls and External Interrupts can be
serialized, that coherency of access to data they both share can be safely
implemented.

System call handlers in this package are always implemented like the
kernel relevant ISRs. On return they can decide to either return to the
calling context or they can demand a context switch. In the former case,
the complete system call behaves like a synchronous function call, however
executed in supervisor mode while the calling context is executed in user
mode.

The two IVOR implementations work together. The share the same C data
structure definitions for execution contexts and context switches. If a
context had been preempted and left (i.e. suspended) by an External
Interrupt ISR then the same context can later become the target for a
context switch and this way it'll be resumed. In the same way can a system
call suspend a context and this context is later target of an IVOR #4 ISR,
which decides on return for a context switch to that context. In total, six paths
are possible for kernel relevant ISRs and system calls:

* The ISR can continue the preempted code, like an ordinary ISR
* The ISR can suspend the preempted context and resume a context, which
  had been suspended earlier by an ISR
* The ISR can suspend the preempted context and resume a context, which
  had been suspended earlier by a system call
* The system call can return to the calling context, like an ordinary
  function call
* The system call can suspend the calling context and resume a context, which
  had been suspended earlier by an ISR
* The system call can suspend the calling context and resume a context, which
  had been suspended earlier by a system call

Whenever the ISR/system call handler decides on return to do a context
switch and if it commands to resume a context that had been suspended by a
context-switching system call, then the handler can provide a uint32_t
value, which is returned to the resumed context as function result of the
context switch, which had made it suspended. Consequently, from the
perspective of the system calling context a system call always looks like
an ordinary function call -- it is invoked and on return a function result
is got. The only observable difference to a normal function call is the
(arbitrarily long) time span between entry into and exit from the system
call.

The added value of this TRK-USB-MPC5643L sample is that all of this
functionality is offered through a C API. The handlers and the described
mechanisms are implemented in assembler code but the client code can be
implemented in proper C code. A complete, cooperative or preemptive
operating system kernel can be build on this platform without any
additional assembler code.

ISRs -- ordinary and kernel relevant -- are dynamically defined by the
client code using the known mechanisms from the common startup code. A
change has been made in the call for registering an ISR: A Boolean
argument makes the distinction between ordinary and kernel relevant and the
type of the ISR function pointer depends on this. Kernel relevant ISRs can
no longer be of type `void (*)(void)` -- they require a signature, which
permits commanding the context switch on return.

System call handlers are collected in a static, constant table of those.
Dynamic adding at run-time is not possible here; the set of system calls
is considered a finalized design decision for the aimed scheduler. The
table is declared extern to the assembler code and the client code is in
charge to compile it.footnote:
  [The assembler implementation of the IVOR #8 handler invokes a
particular system call by index into this table, it doesn't need to known
anything about the table contents. The normal design decision for the
client code will be to provide a preprocessor macro or an inline function
for each system call, which wraps the `init_systemCall(idxSysCall)` with a
meaningful name.]

We saw how to switch between different execution contexts. But where do
they initially come from? And where do they go if no longer needed?

One particular execution context is always there. It's the execution
context from the startup code, passed on to C function `main`. To make use
of the context switching capabilities of the IVOR handlers, we need at
minimum one other context:

Sample kernelBuilder has the implementation of a system call for context
creation. This system call is expected to be put into the client-compiled
table of system calls, additionally to those it will define itself. This
system call can then be used by the client code. It takes Â´the pointer to
a C function `_Noreturn (*)(uint32_t)` as principal argument. The entry
into this C function are the very first instructions of the new context.
From the perspective of the client code programmer, this function will
simply be called. Further arguments of the system call decide whether to
immediately start the new context or not. The more typical case will be
not to do so and control returns to the calling context, which now owns
the new context is suspended state for later resume by an ISR or system
call. Typical design: The kernel initialization routine does do the system
call a number of times to create the requested number of tasks beforehand.
Or it offers a system call for dynamic task creation at run-time; then it
could be useful to offer immediate start of that task.

The implementation of a operating system kernel will have to deal with
task creation and deletion. Our kernelBuilder doesn't do. It has no
concept of memory allocation, new and free, pools of objects, etc.
Therefore you will not find any support of context deletion. For the IVOR
handlers this is simply irrelevant; a no longer required context will just
never be commanded again as target for resume. Whether the client code
uses a free method to release the memory connected to a no longer used
context or whether it returns it into an object pool for re-use is out of
scope and fully in the design-sphere of the client code.

kernelBuilder consists of the source code folder `code\startup` (known
from the other samples, only the standard IVOR #4 handler has been
removed) and folder `code\kernelBuilder`.

The folders in folder `code\samples` contain a sample client
implementation each. Folder `code\serial` is the known implementation of
`printf` and only used by the client code.

The build and debug scripts are a bit different to what you know from the
other samples. They take an argument to select a client code sample;
kernelBuilder itself is an infra-structure only, it is not a
self-contained, flashable executable, you always need to compile it
together with some client code.

The sample demonstrate preemptive and cooperative scheduling.

To see how the sample works you need to open a terminal software on your
host machine. You can find a terminal as part of the CodeWarrior Eclipse
IDE; go to the menu, "Window/Show View/Other/Terminal/Terminal".

Open the serial port, which is offered by the TRK-USB-MPC5643L. (On
Windows, open the Computer Management and go to the Device Manager to find
out.) The Baud rate has been selected as 115200 Bd in file
`code\mai_main.c`, 8 Bit, no parity, 1 start and stop Bit. The terminal
should print the messages, which are regularly sent by the sample code
running on the evaluation board.

=== Book E versus VLE

kernelBuilder is written in Book E assembler. Currently, no VLE
implementation is available. It'll follow later.

The implementation of the sample client code is not specific to one of the
instruction sets. Evidently, the project setup is done for Book E.

== Tools

=== Environment

==== Command line based build

The makefiles and related scripts require a few settings of the
environment in the host machine. In particular, the location of the GNU
compiler installation needs to be known and the PATH variable needs to
contain the paths to the required tools. 

For Windows users there is a shortcut to PowerShell in the root of this
project (not sample), which opens the shell with the prepared environment.
Furthermore, it creates an alias to the appropriate GNU make executable.
You can simply type `make` from any location to run MinGW32 GNU make.

The PowerShell process reads the script `setEnv.ps1`, located in the
project root, too, to configure the environment. This script requires
configuration prior to its first use. Windows users open it in a text
editor and follow the given instructions that are marked by TODO tags.
Mainly, it's about specifying the installation directory of GCC.

Non-Windows users will read this script to see, which (few) environmental
settings are needed to successfully run the build and prepare an according
script for their native shell.

==== Eclipse for building, flashing and debugging

Flashing and debugging is always done using the NXP CodeWarrior Eclipse
IDE, which is available for free download. If you are going to run the
application build from Eclipse, too, then the same environmental settings
as described above for a shell based build need to be done for Eclipse. The
easiest way to do so is starting Eclipse from a shell, that has executed
the script `setEnv.ps1` prior to opening Eclipse.

For Windows users the script `CW-IDE.ps1` has been prepared. This script
requires configuration prior to its first use. Windows users open it in a
text editor and follow the given instructions that are marked by TODO
tags. Mainly, it's about specifying the installation directory of
CodeWarrior.

Non-Windows users will read this script to see, which (few) environmental
and path settings are needed to successfully run the build under control
of Eclipse and prepare an according script for their native shell.

Once everything is prepared, the CodeWarrior Eclipse IDE will never be
started other than by clicking the script `CW-IDE.ps1` or its equivalent
on non-Windows hosts.

See https://github.com/PeterVranken/TRK-USB-MPC5643L[project overview] and
https://github.com/PeterVranken/TRK-USB-MPC5643L/wiki/Tools-and-Installation[GitHub
Wiki] for more details about downloading and installing the required
tools.

=== Compiler and makefile

Compilation and linkage are makefile controlled. The compiler is GCC
(MinGW-powerpc-eabivle-4.9.4). The makefile is made generic and can be
reused for other projects, not only for a tiny "Hello World" with a few
source files. It supports a number of options (targets); get an overview
by typing:
 
    cd <projectRoot>/LSM/kernelBuilder
    mingw32-make help

The main makefile `GNUmakefile` has been configured for the build of
sample "kernelBuilder". By default the sample client code is
`alternatingContexts`. Type: 

    mingw32-make -s build 
    mingw32-make -s build CONFIG=PRODUCTION

to produce the flashable files
`bin\ppc\alternatingContexts\DEBUG\TRK-USB-MPC5643L-kernelBuilder.elf` 
and
`bin\ppc\alternatingContexts\PRODUCTION\TRK-USB-MPC5643L-kernelBuilder.elf`.

To select the compilation of kernelBuilder with the other sample client
code add APP=code/samples/chainedContextCreation to the command line of
mingw32-make.

NOTE: The makefile requires the MinGW port of the make processor. The Cygwin
port will fail with obscure, misleading error messages. It's safe to use
the `make.exe` from the compiler installation archive. The makefile is
designed to run on different host systems but has been tested with Windows
7 only.

=== Flashing and debugging

The sample code can be flashed and debugged with the CodeWarrior IDE.

To flash the `*.elf` file, open the CodeWarrior IDE, go to the menu, click
"Window/Show View/Other/Debug/Debugger Shell". In the debugger shell
window, type:

    cd <rootFolderOfSample>/makefile/debugger
    source flashAlternatingContextsDEBUG.tcl
    
or

    source flashAlternatingContextsPRODUCTION.tcl

(Or the according scripts for the other sample client code.)

The debugger is started by a click on the black triangle next to the blue
icon "bug", then click "Debug Configurations.../CodeWarrior/kernelBuilder
(alternatingContexts, DEBUG)". Confirm and start the debugger with a last click on button
"Debug".

(Or select the according debug configuration for the other sample client.)

You can find more details on using the CodeWarrior IDE at
https://github.com/PeterVranken/TRK-USB-MPC5643L/wiki/Tools-and-Installation.

== Code architecture

This sample builds on the basic sample "startup" located in a sibling folder. 
"kernelBuilder" is compiled for the Book E instruction set. All build settings
and the software architecture are identical to "startup". Please refer to
https://github.com/PeterVranken/TRK-USB-MPC5643L/blob/master/LSM/startup/readMe.adoc[LSM/startup/readMe.adoc]
for details.

=== API

kernelBuilder offers an API for using it. This API is an extension to the
https://github.com/PeterVranken/TRK-USB-MPC5643L/blob/master/LSM/startup/readMe.adoc[API
offered by the startup code] and which is still required, too. This
section outlines, which functions and data structures are available and how to use them.
Detailed information is found as
https://github.com/PeterVranken/TRK-USB-MPC5643L/blob/master/LSM/kernelBuilder/code/kernelBuilder/int_interruptHandler.h[source
code] comments.

==== TODOC New API by kernelBuilder

==== Registering an ISR

This function from the startup API lets your application define a handler
for all needed interrupt sources.

    #include "ihw_initMcuCoreHW.h"
    void ihw_installINTCInterruptHandler( void (*interruptHandler)(void)
                                        , unsigned short vectorNum
                                        , unsigned char psrPriority
                                        , bool isPreemptable
                                        );

TODOC: Signature has changed to differentiate ordinary and kernel relevant ISRs

=== TODOC Simple sample code

== Known issues

Debugger: If the view shows the INTC0 register set then the debugger
harmfully affects program execution and the code fails: The write to
INTC_EOIR_PRC0, which normally restores the current priority level
INTC_CPR_PRC0, now fails to do so.

This effect can be observed with other samples, too.

Workaround: Don't open the view of the INTC0 in the debugger when
debugging an RTOS application. Then the INTC and the code work fine.